#!/bin/sh
# -----------------------------------------------------------------------------
# WARNING: This tool performs real network requests that may reveal investigated
# URLs or hosts to third parties. Specifically:
#
# • Redirect resolution uses curl to contact the target server directly,
#   revealing the queried URL to the destination and any intermediate redirectors.
# • VirusTotal lookups and (optionally) uploads go through the public API and
#   are logged by VirusTotal.
# • DNS resolution uses your system’s configured resolver. After resolving an
#   address, ASN ownership information is retrieved from ipinfo.io for each
#   resolved IPv4 address.
# • RDAP and WHOIS lookups are sent to registry or registrar servers and may be
#   logged by those operators.
#
#
# Use this tool with caution when investigating internal, private, or sensitive
# URLs or infrastructure. It is intended for open-web triage and educational
# use, not confidential analysis.
# -----------------------------------------------------------------------------
# checklink — URL Risk Indicator (v0.5.1 / POSIX sh)
#
# License: MIT
#
# Description:
#   High-signal, minimal tool to assess URL risk indicators.
#   - VirusTotal verdict (lookup-only by default; optional upload with -u)
#   - Domain age (RDAP / .gr WHOIS) — printed as "Registration hint"
#   - Certificate age & issuer, with "fresh cert" warnings
#   - URL heuristics (scheme, subdomains, TLD, punycode, userinfo, IPv4 literal)
#   - DNS resolution + ASN lookup (IPv4 only, via ipinfo.io)
#
# Dependencies:
#   curl, jq, vt (VirusTotal CLI), openssl
# Optional:
#   whois (for .gr), dig (DNS)
#
# Environment:
#   VT_ALLOW_UPLOAD=0   # privacy-first default. Set to 1 or use -u to upload.
#
# Usage:
#   checklink [-q] [-u] [--no-age] [--version] <url-or-domain>
#
# Examples:
#   checklink https://suspicious-site.com
#   checklink -q domain.gr                # quiet mode, domain only
#   checklink --no-age bit.ly/abc123      # skip age checks
#   checklink -u suspicious-url.com       # upload new URL to VirusTotal
# -----------------------------------------------------------------------------

set -o nounset
# shellcheck disable=SC3040
set -o pipefail 2>/dev/null || true  # some /bin/sh lack pipefail

# ---------------- Dependency checks ----------------
for dep in curl jq openssl; do
  command -v "$dep" >/dev/null 2>&1 || {
    echo "Error: $dep is required but not installed." >&2
    exit 1
  }
done

# ---------------- Config / constants ----------------
VT_ALLOW_UPLOAD="${VT_ALLOW_UPLOAD:-0}"
MAX_CURL_TIME=10
WHOIS_TIMEOUT=5
MAX_REDIRECTS=5
MAX_URL_LEN=2048

quiet=0
do_age=1

SHORTENERS="bit.ly t.co tinyurl.com is.gd cutt.ly short.link ow.ly buff.ly goo.gl rebrand.ly rb.gy trib.al shorturl.at linktr.ee"
RISKY_TLDS="tk ml ga cf gq top click download zip mov"

# ---------------- Output helper ----------------
emit() { printf '%s\n' "$*"; }

# ---------------- Small helpers ----------------
get_scheme() {
  printf '%s' "$1" | sed -n 's#^\([A-Za-z][A-Za-z0-9+.-]*\)://.*#\1#p'
}
get_host() {
  # Simple authority → host (no IPv6 literal support by design)
  s=$1
  s=${s#*://}
  s=${s%%/*}
  s=${s%%\?*}
  s=${s%%\#*}
  h=${s%%:*}   # drop :port
  printf '%s' "$h" | tr '[:upper:]' '[:lower:]'
}

# Extract registered domain (eTLD+1) for RDAP/WHOIS
# Pragmatic heuristic: assumes standard TLDs (.com, .org, etc.) and common ccTLDs
get_registered_domain() {
  fqdn="$1"
  # Handle known 2-level TLDs (co.uk, com.au, etc.)
  case "$fqdn" in
    *.co.uk|*.com.au|*.co.jp|*.co.nz|*.co.za|*.com.br|*.com.mx|*.com.ar)
      printf '%s' "$fqdn" | awk -F. '{if(NF>=3) print $(NF-2)"."$(NF-1)"."$NF; else print $0}'
      ;;
    *)
      # Standard TLD: take last 2 labels
      printf '%s' "$fqdn" | awk -F. '{if(NF>=2) print $(NF-1)"."$NF; else print $0}'
      ;;
  esac
}

is_printable_and_sane() {
  s="$1"
  [ "${#s}" -le "$MAX_URL_LEN" ] || return 1
  printf '%s' "$s" | LC_ALL=C grep -q '^[[:print:]]\+$' || return 1
  return 0
}
has_allowed_scheme() { case "$1" in http://*|https://*) return 0;; *) return 1;; esac; }

# Validate host for downstream tools (IPv4 or DNS name; no IPv6 literals)
is_safe_host() {
  h="$1"
  # IPv4 literal
  if printf '%s' "$h" | grep -q '^\([0-9]\{1,3\}\.\)\{3\}[0-9]\{1,3\}$'; then
    return 0
  fi
  # DNS hostname (labels letters/digits/hyphen)
  if printf '%s' "$h" | grep -q '^[a-z0-9][a-z0-9-]*\(\.[a-z0-9][a-z0-9-]*\)\+$'; then
    total_len=${#h}
    [ "$total_len" -le 253 ] || return 1
    oldIFS=$IFS; IFS=.
    # shellcheck disable=SC2086
    set -- $h
    IFS=$oldIFS
    for lbl in "$@"; do
      len=${#lbl}
      [ "$len" -ge 1 ] && [ "$len" -le 63 ] || return 1
    done
    return 0
  fi
  return 1
}

# Portable date parsing: BSD first (-j -f), GNU second (-d)
parse_date_portable() {
  date -j -f "%b %e %T %Y %Z" "$1" +%s 2>/dev/null || \
  date -d "$1" +%s 2>/dev/null || \
  echo 0
}

# VirusTotal JSON verdict normalizer
verdict_from_stats() {
  jq -r '
    def S: .last_analysis_stats // .stats // empty;
    def G: ( .data? // . ) | (if type=="array" then .[] else . end) | ( .attributes? // . );
    ( [ G | S ][0] ) as $s
    | if ($s|type) == "null" then "Unknown"
      else
        ($s.malicious // 0) as $m |
        ($s.suspicious // 0) as $u |
        if    $m > 0 then "Malicious (\($m))"
        elif  $u > 0 then "Suspicious (\($u))"
        elif  ($m==0 and $u==0) then "No detections"
        else  "Unknown"
        end
      end
  '
}

# ---------------- Heuristics (high value / low noise) ----------------
has_userinfo() {
  url="$1"
  rest="${url#*://}"
  [ "$rest" = "$url" ] && return 1
  auth="${rest%%/*}"
  auth="${auth%%\?*}"
  auth="${auth%%#*}"
  case "$auth" in *"@"*) return 0;; *) return 1;; esac
}

check_suspicious_patterns() {
  url="$1"
  scheme=$(get_scheme "$url")
  host=$(get_host "$url")

  [ -z "$host" ] && return 0

  # 1) Non-HTTPS
  [ -n "$scheme" ] && [ "$scheme" != "https" ] && emit "WARN:non_https:$scheme"

  # 2) Userinfo in authority (user:pass@host)
  if has_userinfo "$url"; then
    emit "WARN:userinfo_present:yes"
  fi

  # 3) IP literal host (IPv4 only)
  if printf '%s' "$host" | grep -q '^\([0-9]\{1,3\}\.\)\{3\}[0-9]\{1,3\}$'; then
    emit "WARN:ip_literal:$host"
  fi

  # 4) Punycode
  case "$host" in *xn--*) emit "WARN:punycode:$host";; esac

  # 5) Excessive subdomains: labels >= 5 ⇒ 3+ subdomains
  oldIFS=$IFS; IFS=.
  # shellcheck disable=SC2086
  set -- $host
  IFS=$oldIFS
  nlabels=$#
  [ "$nlabels" -ge 5 ] && emit "WARN:subdomain_count:$nlabels"

  # 6) Known URL shorteners
  for s in $SHORTENERS; do
    [ "$host" = "$s" ] && { emit "WARN:url_shortener:$host"; break; }
  done

  # 7) Risky TLDs
  tld="${host##*.}"
  for r in $RISKY_TLDS; do
    [ "$tld" = "$r" ] && { emit "WARN:risky_tld:$tld"; break; }
  done

  # 8) Double hyphen (ignore punycode)
  case "$host" in
    *"--"*)
      case "$host" in *xn--*) : ;; *) emit "WARN:double_hyphen:$host";; esac
    ;;
  esac

  # 9) Very long host
  [ "${#host}" -gt 75 ] && emit "WARN:long_host:${#host}"

  # 10) Very long URL (often obfuscated phishing)
  [ "${#url}" -gt 200 ] && emit "WARN:long_url:${#url}"
}

# ---------------- DNS + ASN (IPv4 only) ----------------
get_asn_info() {
  ip="$1"
  curl -s --max-time 3 "https://ipinfo.io/${ip}/org" 2>/dev/null
}

dns_checks() {
  host="$1"
  command -v dig >/dev/null 2>&1 || return 0

  a=$(dig +time=2 +tries=1 +short A "$host" 2>/dev/null | sed '/^;/d' | sort -u)

  if [ -z "$a" ]; then
    emit "WARN:nx_domain:yes"
    return 0
  fi

  echo "$a" | while IFS= read -r rec; do
    [ -z "$rec" ] && continue
    # Skip CNAMEs (not IPv4 addresses)
    printf '%s' "$rec" | grep -q '^\([0-9]\{1,3\}\.\)\{3\}[0-9]\{1,3\}$' || continue
    asn=$(get_asn_info "$rec")
    if [ -n "$asn" ]; then emit "INFO:dns_a:$rec ($asn)"; else emit "INFO:dns_a:$rec"; fi
    case "$rec" in
      10.*|192.168.*|172.1[6-9].*|172.2[0-9].*|172.3[0-1].*|127.*|169.254.*) emit "WARN:private_ip:$rec" ;;
    esac
  done
}

# ---------------- TLS certificate inspection ----------------
# Single-label wildcard match: *.example.com matches foo.example.com only
_cert_host_matches() {
  host="$1"; name="$2"

  [ "$host" = "$name" ] && return 0

  case "$name" in
    '*.'*)
      suf="${name#*.}"
      case "$host" in
        *."$suf")
          h_labels=$(printf '%s' "$host" | awk -F'.' '{print NF}')
          s_labels=$(printf '%s' "$suf"  | awk -F'.' '{print NF}')
          [ "$h_labels" -eq $((s_labels + 1)) ] && return 0
        ;;
      esac
    ;;
  esac

  return 1
}

# Fetch cert and cache in CERT_DATA for use by both functions
_cert_fetch() {
  host="$1"; port="${2:-443}"
  CERT_DATA=$(echo | openssl s_client -servername "$host" -connect "$host:$port" 2>/dev/null \
              | openssl x509 -noout -text -subject -startdate -issuer 2>/dev/null) || CERT_DATA=""
  export CERT_DATA
}

# Emit TLS-related warnings (called with other heuristics)
tls_warnings() {
  host="$1"
  [ -z "${CERT_DATA:-}" ] && return 0

  start_line=$(printf '%s\n' "$CERT_DATA" | sed -n 's/^notBefore=//p' | head -1)

  if [ -n "$start_line" ]; then
    # Fresh-cert warnings
    start_epoch=$(parse_date_portable "$start_line")
    if [ "$start_epoch" -gt 0 ] 2>/dev/null; then
      now_epoch=$(date +%s)
      days=$(( (now_epoch - start_epoch) / 86400 ))

      if [ "$days" -lt 2 ] 2>/dev/null; then
        emit "WARN:very_fresh_cert:${days}d"
      elif [ "$days" -lt 7 ] 2>/dev/null; then
        [ -n "${DOMAIN_AGE_YEARS:-}" ] && [ "$DOMAIN_AGE_YEARS" -ge 1 ] 2>/dev/null && \
          emit "WARN:fresh_cert_mature_domain:${days}d"
      fi
    fi
  fi

  # Check hostname matches certificate (SANs or CN)
  sans=$(
    printf '%s\n' "$CERT_DATA" |
    awk '
      /Subject Alternative Name/ {in_san=1; next}
      /X509v3/ {in_san=0}
      in_san {print}
    ' |
    tr ',' '\n' |
    sed -n 's/^[[:space:]]*DNS:[[:space:]]*//p' |
    tr '[:upper:]' '[:lower:]'
  )

  if [ -z "$sans" ]; then
    cn=$(printf '%s\n' "$CERT_DATA" \
         | sed -n 's/^subject=.*CN=\([^,/]*\).*/\1/p' \
         | tr '[:upper:]' '[:lower:]' | head -1)
    [ -n "$cn" ] && sans="$cn"
  fi

  if [ -n "$sans" ]; then
    matched=0
    while IFS= read -r name; do
      [ -z "$name" ] && continue
      if _cert_host_matches "$host" "$name"; then
        matched=1
        break
      fi
    done <<EOF
$sans
EOF
    [ "$matched" -eq 0 ] && emit "WARN:cert_name_mismatch:$host"
  fi
}

# Print cert info line (called separately for display)
tls_cert_info() {
  [ -z "${CERT_DATA:-}" ] && return 1

  start_line=$(printf '%s\n' "$CERT_DATA" | sed -n 's/^notBefore=//p' | head -1)
  issuer=$(printf '%s\n' "$CERT_DATA" | sed -n 's/^issuer=//p' | head -1)

  emit "Certificate: $start_line — issuer: $issuer"
}

# ---------------- Domain age (RDAP / .gr WHOIS) ----------------
domain_age_block() {
  domain="$1"
  # Normalize to registered domain (eTLD+1) for RDAP/WHOIS
  reg_domain=$(get_registered_domain "$domain")
  tld=$(printf '%s' "$reg_domain" | awk -F. '{print tolower($NF)}')

  # .gr WHOIS first (RDAP unreliable for .gr)
  if [ "$tld" = "gr" ]; then
    if command -v timeout >/dev/null 2>&1; then
      whois_out=$(timeout "$WHOIS_TIMEOUT" whois -h grwhois.ics.forth.gr "$reg_domain" 2>/dev/null || true)
    elif command -v gtimeout >/dev/null 2>&1; then
      whois_out=$(gtimeout "$WHOIS_TIMEOUT" whois -h grwhois.ics.forth.gr "$reg_domain" 2>/dev/null || true)
    else
      # No timeout available, skip WHOIS to avoid hangs
      whois_out=""
    fi
    creation_line=$(printf '%s' "$whois_out" \
      | awk 'BEGIN{IGNORECASE=1}
             /^(Registration Date|Created On|Creation Date|Registered On|Registered Date|Creation Time):/ {print; exit}' \
      | tr -s " ")
    if [ -n "$creation_line" ]; then
      reg_year=$(
        printf '%s\n' "$creation_line" |
          awk '{
            for (i=1;i<=NF;i++) if ($i ~ /^(19|20)[0-9]{2}$/) { print $i; exit }
          }'
      )
      if [ -n "$reg_year" ]; then
        age=$(( $(date +%Y) - reg_year ))
        DOMAIN_AGE_YEARS="$age"; export DOMAIN_AGE_YEARS
        emit "Registration hint: year=$reg_year; age=${age}y (WHOIS-gr)"
      else
        emit "Registration hint: unavailable (WHOIS-gr)"
      fi
      return 0
    fi
  fi

  # RDAP (generic) - follow redirects and (if needed) one registrar referral
  rdap_json=$(
    curl -sSL --max-time "$MAX_CURL_TIME" \
         -H 'User-Agent: Mozilla/5.0' \
         -H 'Accept: application/rdap+json, application/json;q=0.9, */*;q=0.1' \
         "https://rdap.org/domain/${reg_domain}" 2>/dev/null || true
  )

  # Try registry-provided registration event
  reg_date=$(printf '%s' "$rdap_json" |
    jq -r 'try (.events[]? | select(.eventAction=="registration") | .eventDate) catch ""' 2>/dev/null)

  if [ -z "$reg_date" ] || [ "$reg_date" = "null" ]; then
    # Find canonical "self" to avoid loops
    self_url=$(printf '%s' "$rdap_json" |
      jq -r '.links[]? | select(.rel=="self") | .href' 2>/dev/null | head -1)

    # Prefer registrar entity links if available
    ref_url=$(printf '%s' "$rdap_json" |
      jq -r '
        # first try registrar entity links
        ( .entities[]? | select(.roles[]?=="registrar") | .links[]? | .href? ) // empty
      ' 2>/dev/null | head -1)

    # Fallback to any related/authoritative link that looks like a domain RDAP URL
    if [ -z "$ref_url" ] || [ "$ref_url" = "null" ]; then
      ref_url=$(printf '%s' "$rdap_json" |
        jq -r '
          .links[]? | select((.rel=="related" or .rel=="authoritative" or .rel=="authority" or .rel=="alternate") and (.href?)) | .href
        ' 2>/dev/null | grep '/domain/' | head -1)
    fi

    # Follow one referral if it exists and is not the same as self
    if [ -n "$ref_url" ] && [ "$ref_url" != "null" ] && [ "$ref_url" != "$self_url" ]; then
      rdap_ref=$(
        curl -sSL --max-time "$MAX_CURL_TIME" \
             -H 'User-Agent: Mozilla/5.0' \
             -H 'Accept: application/rdap+json, application/json;q=0.9, */*;q=0.1' \
             "$ref_url" 2>/dev/null || true
      )
      reg_date=$(printf '%s' "$rdap_ref" |
        jq -r 'try (.events[]? | select(.eventAction=="registration") | .eventDate) catch ""' 2>/dev/null)
    fi
  fi

  if [ -n "$reg_date" ] && [ "$reg_date" != "null" ]; then
    reg_year=$(
      printf '%s\n' "$reg_date" |
        awk -F'T' '{print $1}' | awk -F'-' '{print $1}'
    )
    if [ -n "$reg_year" ]; then
      age=$(( $(date +%Y) - reg_year ))
      DOMAIN_AGE_YEARS="$age"; export DOMAIN_AGE_YEARS
      emit "Registration hint: date=$reg_date; age=${age}y (RDAP)"
    else
      emit "Registration hint: date=$reg_date (RDAP)"
    fi
    return 0
  fi

  # Neither WHOIS nor RDAP yielded a registration date
  emit "Registration hint: unavailable"
  return 1
}

# ---------------- Arg parsing ----------------
while [ $# -gt 0 ]; do
  case "$1" in
    -q) quiet=1; shift ;;
    -u|--upload) VT_ALLOW_UPLOAD=1; shift ;;
    --no-age) do_age=0; shift ;;
    --version) emit "checklink v0.5.1"; exit 0 ;;
    --) shift; break ;;
    -*)
      echo "Usage: checklink [-q] [-u] [--no-age] [--version] <url-or-domain>" >&2
      exit 1
      ;;
    *) break ;;
  esac
done

if [ $# -lt 1 ]; then
  echo "Usage: checklink [-q] [-u] [--no-age] [--version] <url-or-domain>" >&2
  exit 1
fi

input_raw="$1"

# Normalize bare domains to https://domain/
case "$input_raw" in
  *://*) input_url="$input_raw" ;;
  *)     input_url="https://$input_raw" ;;
esac

# Remove accidental backslashes before ?, =, &
sanitized_url=$(printf '%s' "$input_url" | sed 's/\\\([?=&]\)/\1/g')

# Validate input early
if ! is_printable_and_sane "$input_raw"; then
  echo "Error: input contains control chars or exceeds ${MAX_URL_LEN} bytes." >&2
  exit 2
fi
if ! has_allowed_scheme "$sanitized_url"; then
  echo "Error: only http(s) URLs are supported." >&2
  exit 2
fi

# Explicitly reject IPv6 literal URLs (bracketed), by design
case "$sanitized_url" in
  *://\[*\]*)
    echo "Error: IPv6 literal URLs are not supported — treat them as suspicious." >&2
    exit 2
    ;;
esac

host_check=$(get_host "$sanitized_url")
if ! is_safe_host "$host_check"; then
  echo "Error: invalid or unsafe host: $host_check" >&2
  exit 2
fi

# ---------------- Resolve redirects (hardened) ----------------
# capture HTTP code and final URL
# shellcheck disable=SC2046
set -- $(curl -fsSL -g --path-as-is \
   --max-time "$MAX_CURL_TIME" \
   --max-redirs "$MAX_REDIRECTS" \
   --proto '=https,http' \
   --proto-redir '=https,http' \
   -H 'User-Agent: Mozilla/5.0' \
   -o /dev/null \
   -w '%{http_code} %{url_effective}' \
   "$sanitized_url")
http_code="$1"
final_url="$2"

if [ -z "${final_url:-}" ]; then
  emit "Summary: Unknown (unresolved)"
  exit 2
fi

input_domain=$(get_host "$sanitized_url")
final_domain=$(get_host "$final_url")

# Optional runtime notice when uploading (non-quiet mode)
if [ "$VT_ALLOW_UPLOAD" -eq 1 ] && [ "$quiet" -eq 0 ]; then
  emit "Note: uploading URL to VirusTotal for fresh analysis (may disclose the URL)."
fi

# ---------------- VirusTotal ----------------
# Ensure vt CLI exists
command -v vt >/dev/null 2>&1 || {
  echo "Error: vt CLI not found. Install: https://github.com/VirusTotal/vt-cli" >&2
  exit 1
}

url_for_vt="$final_url"
case "$http_code" in
  4*|5*) url_for_vt="$sanitized_url" ;;
esac

vt_lookup=$(vt url "$url_for_vt" --format json 2>/dev/null || true)
vt_verdict=""
if [ -n "$vt_lookup" ]; then
  vt_verdict=$(printf '%s' "$vt_lookup" | verdict_from_stats 2>/dev/null || true)
fi

if [ -z "$vt_verdict" ] || [ "$vt_verdict" = "Unknown" ]; then
  if [ "$VT_ALLOW_UPLOAD" -eq 1 ]; then
    vt_scan=$(vt scan url "$url_for_vt" --wait --format json 2>/dev/null || true)
    if [ -n "$vt_scan" ]; then
      vt_verdict=$(printf '%s' "$vt_scan" | verdict_from_stats 2>/dev/null || true)
    fi
    [ -z "$vt_verdict" ] && vt_verdict="Unavailable"
  else
    vt_verdict="No report (not uploaded)"
  fi
fi

# ---------------- Domain age & cert fetch ----------------
input_reg_line=""
if [ "$do_age" -eq 1 ]; then
  [ -n "$input_domain" ] && input_reg_line=$(domain_age_block "$input_domain" || true)
  [ -n "$final_domain" ] && _cert_fetch "$final_domain"
fi

# ---------------- Heuristics & DNS & TLS warnings ----------------
warnings_text=$( (check_suspicious_patterns "$final_url"; dns_checks "$final_domain"; tls_warnings "$final_domain") | sed '/^$/d' )

# ---------------- Output ----------------
if [ "$quiet" -eq 1 ]; then
  emit "Summary: $vt_verdict | $final_url"
  [ -n "$warnings_text" ] && emit "$warnings_text"

  # Exit codes: 0=clean, 3=warnings, 4=malicious/suspicious
  exit_code=0
  if printf '%s' "$vt_verdict" | grep -qE "Malicious|Suspicious"; then
    exit_code=4
  elif printf '%s' "$warnings_text" | grep -q "^WARN:"; then
    exit_code=3
  fi
  exit "$exit_code"
fi

# Show input vs final if they differ
if [ "$input_domain" != "$final_domain" ]; then
  emit "Input:  $sanitized_url"
  emit "Final:  $final_url (HTTP $http_code)"
else
  emit "URL:    $final_url (HTTP $http_code)"
fi

emit "VT:     $vt_verdict"

if [ "$do_age" -eq 1 ]; then
  if [ "$input_domain" != "$final_domain" ]; then
    # Strip "Registration hint:" prefix and add our own label
    if [ -n "$input_reg_line" ]; then
      clean_reg=$(printf '%s' "$input_reg_line" | sed 's/^Registration hint: //')
      emit "Registration (input): $clean_reg"
    else
      emit "Registration (input): unavailable"
    fi
    if ! tls_cert_info; then
      emit "Certificate (final): unavailable"
    fi
  else
    if [ -n "$input_reg_line" ]; then
      emit "$input_reg_line"
    else
      emit "Registration hint: unavailable"
    fi
    if ! tls_cert_info; then
      emit "Certificate: unavailable"
    fi
  fi
fi

[ -n "$warnings_text" ] && emit "$warnings_text"

# Exit codes: 0=clean, 3=warnings, 4=malicious/suspicious
exit_code=0
if printf '%s' "$vt_verdict" | grep -qE "Malicious|Suspicious"; then
  exit_code=4
elif printf '%s' "$warnings_text" | grep -q "^WARN:"; then
  exit_code=3
fi
exit "$exit_code"